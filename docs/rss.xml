<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Love life Love code</title><link>https://hacker4257.github.io/</link><description>Love life Love code</description><copyright>Love life Love code</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://hacker4257.github.io/ava.jpeg</url><title>avatar</title><link>https://hacker4257.github.io/</link></image><lastBuildDate>Thu, 10 Oct 2024 02:46:14 +0000</lastBuildDate><managingEditor>Love life Love code</managingEditor><ttl>60</ttl><webMaster>Love life Love code</webMaster><item><title>开源大模型 Llama 实战</title><link>https://hacker4257.github.io//post/kai-yuan-da-mo-xing-%20Llama%20-shi-zhan.html</link><description>近年来，开源大模型的飞速发展为人工智能应用领域提供了更多的可能性。</description><guid isPermaLink="true">https://hacker4257.github.io//post/kai-yuan-da-mo-xing-%20Llama%20-shi-zhan.html</guid><pubDate>Thu, 10 Oct 2024 02:45:50 +0000</pubDate></item><item><title> 提示工程学习笔记</title><link>https://hacker4257.github.io//post/%20-ti-shi-gong-cheng-xue-xi-bi-ji.html</link><description>&#13;
提示工程（Prompt Engineering）是一种通过设计和优化给定的提示（Prompt）来控制AI生成内容质量的技术。</description><guid isPermaLink="true">https://hacker4257.github.io//post/%20-ti-shi-gong-cheng-xue-xi-bi-ji.html</guid><pubDate>Wed, 09 Oct 2024 06:31:11 +0000</pubDate></item><item><title>Leetcode系列之Z字行变换</title><link>https://hacker4257.github.io//post/Leetcode-xi-lie-zhi-Z-zi-xing-bian-huan.html</link><description>### 6. Z 字形变换&#13;
### 题目描述&#13;
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</description><guid isPermaLink="true">https://hacker4257.github.io//post/Leetcode-xi-lie-zhi-Z-zi-xing-bian-huan.html</guid><pubDate>Wed, 02 Oct 2024 08:48:35 +0000</pubDate></item><item><title>国庆快乐</title><link>https://hacker4257.github.io//post/guo-qing-kuai-le.html</link><description># enjoy life&#13;
&lt;!-- ##{'timestamp':1727748060}## --&gt;。</description><guid isPermaLink="true">https://hacker4257.github.io//post/guo-qing-kuai-le.html</guid><pubDate>Tue, 01 Oct 2024 02:01:00 +0000</pubDate></item><item><title>如何使用Kubeadm设置Kubernetes集群</title><link>https://hacker4257.github.io//post/ru-he-shi-yong-Kubeadm-she-zhi-Kubernetes-ji-qun.html</link><description>### 实验环境&#13;
MacBook Pro 16-inch, 2019&#13;
&#13;
处理器: 2.4 GHz 8-Core Intel Core i9&#13;
&#13;
内存: 32 GB 2667 MHz DDR4&#13;
&#13;
macos:  Sonoma version 14.2.1 (23C71)&#13;
&#13;
使用UTM虚拟机工具创建3台ubuntu20.04-arm64，虚拟机配置均为2核4G, 采用1个master， 2个node的构架&#13;
&#13;
###  部署架构规划&#13;
| 角色 | 主机名 | 组件 | IP |&#13;
|-------|-------|-------|-------|&#13;
| master | master | etcd、apiserver、controller-manager、scheduler、kubelet、proxy、calico、runc |192.168.64.18&#13;
|node01|node01|pod、kubelet、proxy、calico、runc|192.168.64.19&#13;
|node01|node01|pod、kubelet、proxy、calico、runc|192.168.64.20&#13;
&#13;
### 软件版本&#13;
*docker server ：24.0.7&#13;
&#13;
*containerd ：1.7.12&#13;
&#13;
*kubeadm : v1.30.0&#13;
&#13;
*kubelet : v1.30.0&#13;
&#13;
*kubectl : v1.30.0&#13;
&#13;
### 集群服务初始化 （3*， 所有机器都执行）&#13;
#### 切换为管理员&#13;
```shell&#13;
sudo su&#13;
```&#13;
#### 添加主机名&#13;
```shell&#13;
cat &gt;&gt; /etc/hosts &lt;&lt;EOF&#13;
192.168.64.18 master&#13;
192.168.64.19 node01&#13;
192.168.64.20 node02&#13;
EOF&#13;
&#13;
```&#13;
#### 时间同步&#13;
```shell&#13;
apt update &amp;&amp; apt install ntpdate&#13;
ntpdate cn.ntp.org.cn&#13;
```&#13;
#### 关闭防火墙&#13;
```shell&#13;
systemctl disable ufw &amp;&amp; systemctl stop ufw&#13;
```&#13;
#### 关闭swap分区&#13;
```shell&#13;
swapoff -a  # 临时关闭&#13;
sed -ri 's/.swap*./#&amp;/g' /etc/fstab   # 修改配置文件 sed修改配置文件永久关闭&#13;
```&#13;
#### 启用iptables桥接流量&#13;
```shell&#13;
# 添加配置文件&#13;
cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf&#13;
overlay&#13;
br_netfilter&#13;
EOF&#13;
&#13;
# 加载模块&#13;
modprobe overlay&#13;
modprobe br_netfilter&#13;
&#13;
# 设置所需的Sysctl参数，参数在重新启动时保持不变&#13;
cat  &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf&#13;
net.bridge.bridge-nf-call-iptables = 1&#13;
net.bridge.bridge-nf-call-ip6tables = 1&#13;
net.ipv4.ip_forward = 1&#13;
vm.swappiness = 0&#13;
EOF&#13;
&#13;
# 不重启就应用sysctl参数&#13;
sysctl --system&#13;
&#13;
# 保守建议&#13;
reboot&#13;
```&#13;
#### 安装容器运行时&#13;
k8s支持的容器运行时有很多如docker、containerd、cri-o等等，docker 省事一些，这里选择安装docker&#13;
```shell&#13;
# 安装docker&#13;
apt-get update&#13;
apt install -y docker.io&#13;
&#13;
# 设置docker开机自启&#13;
systemctl start docker&#13;
ststemctl enable docker&#13;
&#13;
# 三个服务都应是running状态&#13;
systemctl status containerd.service&#13;
systemctl status docker.service&#13;
systemctl status docker.socket&#13;
```&#13;
&#13;
#### 配置容器运行时的systemd驱动&#13;
```shell&#13;
&#13;
vim /etc/docker/daemon.json &#13;
&#13;
```&#13;
然后将下面设置加入daemon.js&#13;
```shell&#13;
{&#13;
  'exec-opts': [&#13;
    'native.cgroupdriver=systemd'&#13;
  ]&#13;
}&#13;
&#13;
```&#13;
重启docker&#13;
```shell &#13;
systemctl restart docker&#13;
```&#13;
#### 设置Kubernetes APT存储库的GPG密钥&#13;
```shell &#13;
KUBERNETES_VERSION=1.30&#13;
&#13;
sudo mkdir -p /etc/apt/keyrings&#13;
&#13;
curl -fsSL https://pkgs.k8s.io/core:/stable:/v$KUBERNETES_VERSION/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg&#13;
&#13;
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v$KUBERNETES_VERSION/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list&#13;
&#13;
&#13;
```&#13;
 更新 apt 仓库&#13;
 ```shell&#13;
 apt-get update -y&#13;
 ```&#13;
 #### 安装Kubernetes组件&#13;
 ```shell &#13;
 &#13;
 # 安装一些辅助包&#13;
apt-get install -y apt-transport-https ca-certificates curl gpg&#13;
 &#13;
# 安装指定版本&#13;
apt-get install -y kubelet=1.30.0-1.1 kubectl=1.30.0-1.1 kubeadm=1.30.0-1.1&#13;
&#13;
# 确认服务状态（此时kubelet暂未启动）&#13;
systemctl status kubelet&#13;
 ```&#13;
 ### Kubernetes 初始化（只在master操作）&#13;
 ```shell&#13;
kubeadm init \&#13;
  --control-plane-endpoint='192.168.64.18' \&#13;
  --service-cidr=10.96.0.0/12 \&#13;
  --pod-network-cidr=10.244.0.0/16 \&#13;
  --ignore-preflight-errors=all&#13;
  &#13;
# –-apiserver-advertise-address # 集群通告地址，单master时为控制面使用的的服务器IP&#13;
# –-service-cidr #集群内部虚拟网络，Pod统一访问入口，可以不用更改，直接用上面的参数&#13;
# –-pod-network-cidr #Pod网络，与下面部署的CNI网络组件yaml中保持一致，可以不用更改，直接用上面的参数&#13;
&#13;
 ```&#13;
 初始化成功显示如下&#13;
 ```shell&#13;
 Your Kubernetes control-plane has initialized successfully!&#13;
&#13;
To start using your cluster, you need to run the following as a regular user:&#13;
&#13;
  mkdir -p $HOME/.kube&#13;
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config&#13;
  sudo chown $(id -u):$(id -g) $HOME/.kube/config&#13;
&#13;
Alternatively, if you are the root user, you can run:&#13;
&#13;
  export KUBECONFIG=/etc/kubernetes/admin.conf&#13;
&#13;
You should now deploy a pod network to the cluster.&#13;
Run 'kubectl apply -f [podnetwork].yaml' with one of the options listed at:&#13;
  https://kubernetes.io/docs/concepts/cluster-administration/addons/&#13;
&#13;
You can now join any number of the control-plane node running the following command on each as root:&#13;
&#13;
  kubeadm join 192.168.64.18:6443 --token m5pstt.v2gebrasw9yfzxb6 \&#13;
	--discovery-token-ca-cert-hash sha256:205a991b66a2ec879bd36f66851725fd84201d7306bb088ceda8835ad99450b8 \&#13;
	--control-plane --certificate-key 34a274a91255cf25cda3af0f6ecbfc2876e97196491338aab72ca1b3bd09e1d1&#13;
&#13;
Please note that the certificate-key gives access to cluster sensitive data, keep it secret!&#13;
As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use&#13;
'kubeadm init phase upload-certs --upload-certs' to reload certs afterward.&#13;
&#13;
Then you can join any number of worker nodes by running the following on each as root:&#13;
&#13;
kubeadm join 192.168.64.18:6443 --token m5pstt.v2gebrasw9yfzxb6 \&#13;
	--discovery-token-ca-cert-hash sha256:205a991b66a2ec879bd36f66851725fd84201d7306bb088ceda8835ad99450b8 &#13;
 ```&#13;
 从输出中使用以下命令在master中创建kubeconfig，以便您可以使用kubectl与集群API交互。</description><guid isPermaLink="true">https://hacker4257.github.io//post/ru-he-shi-yong-Kubeadm-she-zhi-Kubernetes-ji-qun.html</guid><pubDate>Mon, 30 Sep 2024 05:01:55 +0000</pubDate></item><item><title>设计模式之备忘录模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-bei-wang-lu-mo-shi.html</link><description>## 备忘录模式&#13;
备忘录模式是一种行为设计模式，它允许保存和恢复对象的内部状态，而无需暴露该对象的实现细节。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-bei-wang-lu-mo-shi.html</guid><pubDate>Sun, 29 Sep 2024 13:09:12 +0000</pubDate></item><item><title>设计模式之模板方法模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-mo-ban-fang-fa-mo-shi.html</link><description>## 模板方法模式&#13;
&#13;
模板方法模式是一种行为型设计模式，它定义了一个操作中的算法的框架，并将一些步骤的执行延迟到子类中。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-mo-ban-fang-fa-mo-shi.html</guid><pubDate>Sat, 28 Sep 2024 06:46:15 +0000</pubDate></item><item><title>设计模式之迭代器模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-die-dai-qi-mo-shi.html</link><description>## 迭代器模式&#13;
&#13;
迭代器模式（Iterator Pattern）是一种行为设计模式，它提供了一种顺序访问集合对象中各个元素的方法，而不需要暴露该对象的内部表示。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-die-dai-qi-mo-shi.html</guid><pubDate>Fri, 27 Sep 2024 03:04:05 +0000</pubDate></item><item><title>从零学数据结构</title><link>https://hacker4257.github.io//post/cong-ling-xue-shu-ju-jie-gou.html</link><description># 第一课：数据结构概述和数组&#13;
&#13;
在这一课中，我们将首先了解数据结构的基本概念，然后深入学习数组这一基本数据结构。</description><guid isPermaLink="true">https://hacker4257.github.io//post/cong-ling-xue-shu-ju-jie-gou.html</guid><pubDate>Thu, 26 Sep 2024 09:43:24 +0000</pubDate></item><item><title>设计模式之函数选项模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-han-shu-xuan-xiang-mo-shi.html</link><description>## 函数选项模式&#13;
&#13;
函数选项模式（Functional Options Pattern）在Go语言中是一种流行的设计模式，用于构建灵活且易于扩展的API。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-han-shu-xuan-xiang-mo-shi.html</guid><pubDate>Wed, 25 Sep 2024 02:59:21 +0000</pubDate></item><item><title>设计模式之组合模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-zu-he-mo-shi.html</link><description>## 组合模式&#13;
组合模式是一种结构型设计模式，用于将对象组织成树形结构以表示部分-整体的层次关系。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-zu-he-mo-shi.html</guid><pubDate>Tue, 24 Sep 2024 02:37:09 +0000</pubDate></item><item><title>设计模式之适配器模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-shi-pei-qi-mo-shi.html</link><description>## 适配器模式&#13;
&#13;
适配器模式（Adapter Pattern）是一种结构型设计模式，它允许不兼容的接口之间进行交互。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-shi-pei-qi-mo-shi.html</guid><pubDate>Mon, 23 Sep 2024 02:58:08 +0000</pubDate></item><item><title>设计模式之策略模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-ce-lve-mo-shi.html</link><description>策略模式（Strategy Pattern）是一种常用的设计模式，属于行为型模式。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-ce-lve-mo-shi.html</guid><pubDate>Sun, 22 Sep 2024 04:47:21 +0000</pubDate></item><item><title>设计模式之访问模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-fang-wen-mo-shi.html</link><description>&#13;
访问模式（Visitor Pattern）是一种行为型设计模式，它允许在不修改已有程序结构的情况下，向已有的对象结构中添加新的操作。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-fang-wen-mo-shi.html</guid><pubDate>Sat, 21 Sep 2024 03:32:41 +0000</pubDate></item><item><title>设计模式之观察者模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi.html</link><description>## 观察者模式&#13;
观察者模式（Observer Pattern）是一种常用的软件设计模式，属于行为型模式。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi.html</guid><pubDate>Fri, 20 Sep 2024 06:49:13 +0000</pubDate></item><item><title>设计模式之命令模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-ming-ling-mo-shi.html</link><description>## 命令模式&#13;
命令模式（Command Pattern）是一种行为型设计模式，它主要目的是将请求或简单操作封装为一个对象。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-ming-ling-mo-shi.html</guid><pubDate>Thu, 19 Sep 2024 00:30:22 +0000</pubDate></item><item><title>设计模式之模板模式</title><link>https://hacker4257.github.io//post/she-ji-mo-shi-zhi-mo-ban-mo-shi.html</link><description>模板方法模式是一种行为设计模式，它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重定义算法的某些特定步骤。</description><guid isPermaLink="true">https://hacker4257.github.io//post/she-ji-mo-shi-zhi-mo-ban-mo-shi.html</guid><pubDate>Wed, 18 Sep 2024 05:03:06 +0000</pubDate></item><item><title>从零学Go系列第一课</title><link>https://hacker4257.github.io//post/cong-ling-xue-Go-xi-lie-di-yi-ke.html</link><description>## 基础篇&#13;
### 第一步：安装Go&#13;
&#13;
1. 访问Go语言的官方网站：https://golang.org/&#13;
2. 点击下载页面，选择适合你的操作系统的安装包（Windows、macOS或Linux）。</description><guid isPermaLink="true">https://hacker4257.github.io//post/cong-ling-xue-Go-xi-lie-di-yi-ke.html</guid><pubDate>Sun, 01 Jan 2023 06:03:07 +0000</pubDate></item><item><title>二分查找：高效解决排序问题的算法</title><link>https://hacker4257.github.io//post/er-fen-cha-zhao-%EF%BC%9A-gao-xiao-jie-jue-pai-xu-wen-ti-de-suan-fa.html</link><description>## 引言&#13;
&#13;
在计算机科学中，查找问题是非常常见的任务之一，尤其是在处理大量数据时。</description><guid isPermaLink="true">https://hacker4257.github.io//post/er-fen-cha-zhao-%EF%BC%9A-gao-xiao-jie-jue-pai-xu-wen-ti-de-suan-fa.html</guid><pubDate>Wed, 10 Aug 2022 01:42:42 +0000</pubDate></item><item><title> 2021年个人年度总结</title><link>https://hacker4257.github.io//post/%202021-nian-ge-ren-nian-du-zong-jie.html</link><description>2021年对我来说是充满挑战与成长的一年。</description><guid isPermaLink="true">https://hacker4257.github.io//post/%202021-nian-ge-ren-nian-du-zong-jie.html</guid><pubDate>Fri, 31 Dec 2021 15:59:00 +0000</pubDate></item><item><title>推荐书籍---《我的第一本算法书》</title><link>https://hacker4257.github.io//post/tui-jian-shu-ji----%E3%80%8A-wo-de-di-yi-ben-suan-fa-shu-%E3%80%8B.html</link><description>### 推荐阅读：《我的第一本算法书》&#13;
![image-20240920175559189](https://github.com/user-attachments/assets/5ac15193-ca77-4a59-a049-2e77dc4dc1e9)&#13;
&#13;
当我们谈论编程和数据结构时，算法是一个不可或缺的主题。</description><guid isPermaLink="true">https://hacker4257.github.io//post/tui-jian-shu-ji----%E3%80%8A-wo-de-di-yi-ben-suan-fa-shu-%E3%80%8B.html</guid><pubDate>Thu, 01 Oct 2020 09:59:51 +0000</pubDate></item><item><title>堆排序</title><link>https://hacker4257.github.io//post/dui-pai-xu.html</link><description>堆排序是一种选择排序的变形，它利用堆这种数据结构的特性来实现排序。</description><guid isPermaLink="true">https://hacker4257.github.io//post/dui-pai-xu.html</guid><pubDate>Tue, 24 Sep 2019 07:41:59 +0000</pubDate></item><item><title>快排</title><link>https://hacker4257.github.io//post/kuai-pai.html</link><description>快速排序是一种高效的排序算法，使用分治法（Divide and Conquer）策略来把一个序列分为较小和较大的两个子序列，然后递归地排序两个子序列。</description><guid isPermaLink="true">https://hacker4257.github.io//post/kuai-pai.html</guid><pubDate>Thu, 01 Aug 2019 11:03:07 +0000</pubDate></item><item><title>《星际穿越》：科学与情感的完美交织</title><link>https://hacker4257.github.io//post/%E3%80%8A-xing-ji-chuan-yue-%E3%80%8B%EF%BC%9A-ke-xue-yu-qing-gan-de-wan-mei-jiao-zhi.html</link><description>## 引言&#13;
![下载](https://github.com/user-attachments/assets/d8bd62fb-072c-4e26-9a5a-0ef1e9b5a76e)&#13;
&#13;
**《星际穿越》**（*Interstellar*），是由克里斯托弗·诺兰（Christopher Nolan）执导的科幻电影，于2014年上映。</description><guid isPermaLink="true">https://hacker4257.github.io//post/%E3%80%8A-xing-ji-chuan-yue-%E3%80%8B%EF%BC%9A-ke-xue-yu-qing-gan-de-wan-mei-jiao-zhi.html</guid><pubDate>Mon, 01 Oct 2018 13:42:42 +0000</pubDate></item><item><title>docker常见命令</title><link>https://hacker4257.github.io//post/docker-chang-jian-ming-ling.html</link><description>### 1. 基础命令&#13;
&#13;
- **查看 Docker 版本**&#13;
  ```bash&#13;
  docker --version&#13;
  ```&#13;
&#13;
- **查看 Docker 状态**&#13;
  ```bash&#13;
  docker info&#13;
  ```&#13;
&#13;
### 2. 容器操作&#13;
&#13;
- **拉取镜像**&#13;
  ```bash&#13;
  docker pull &lt;image_name&gt;&#13;
  ```&#13;
  从 Docker Hub 拉取指定镜像。</description><guid isPermaLink="true">https://hacker4257.github.io//post/docker-chang-jian-ming-ling.html</guid><pubDate>Wed, 21 Jun 2017 15:56:49 +0000</pubDate></item><item><title>docker简介</title><link>https://hacker4257.github.io//post/docker-jian-jie.html</link><description>### Docker: 引领容器化技术的革命&#13;
&#13;
在软件开发和部署的世界中，Docker 已经成为一个革命性的名词。</description><guid isPermaLink="true">https://hacker4257.github.io//post/docker-jian-jie.html</guid><pubDate>Fri, 09 Jun 2017 03:56:28 +0000</pubDate></item><item><title>里约奥运会</title><link>https://hacker4257.github.io//post/li-yue-ao-yun-hui.html</link><description>里约热内卢奥运会（2016年夏季奥林匹克运动会）是一项全球性的体育盛事，于2016年8月5日至21日在巴西里约热内卢举行。</description><guid isPermaLink="true">https://hacker4257.github.io//post/li-yue-ao-yun-hui.html</guid><pubDate>Sun, 23 Oct 2016 04:00:50 +0000</pubDate></item><item><title>从零学Python系列第一课</title><link>https://hacker4257.github.io//post/cong-ling-xue-Python-xi-lie-di-yi-ke.html</link><description>### Python基础&#13;
&#13;
#### 1. Python简介&#13;
&#13;
Python是一种广泛使用的高级编程语言，它由Guido van Rossum在1989年设计并于1991年首次发布。</description><guid isPermaLink="true">https://hacker4257.github.io//post/cong-ling-xue-Python-xi-lie-di-yi-ke.html</guid><pubDate>Wed, 23 Sep 2015 03:49:39 +0000</pubDate></item><item><title>hello world</title><link>https://hacker4257.github.io//post/hello%20world.html</link><description>开通博客第一篇写点什么呢？ 没有什么比 hello world 经典。</description><guid isPermaLink="true">https://hacker4257.github.io//post/hello%20world.html</guid><pubDate>Mon, 09 Jun 2014 00:13:35 +0000</pubDate></item><item><title>自我介绍</title><link>https://hacker4257.github.io//about.html</link><description>hi！我是 hacker4257，一名全栈开发工程师，专注于使用 **Golang**、**Python** 和 **React** 开发高效、可扩展的应用程序。</description><guid isPermaLink="true">https://hacker4257.github.io//about.html</guid><pubDate>Fri, 20 Sep 2024 10:21:56 +0000</pubDate></item></channel></rss>